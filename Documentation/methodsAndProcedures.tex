%----------------------------------------------------------------------------------------
%	METHODS AND PROCEDURES
% • The experimental design, methods of gathering data.
% • Subsections.
%----------------------------------------------------------------------------------------
\section{General approach} \label{sec:generalApproach}
	Different approaches have been proposed to describe finite difference method in many books. In case of this report I will base on explanation in chapter 3.5 in Computational Techniques for Fluid Dynamics\cite{bib:fletcher} written by C. A. J. Fletcher. The basis for the finite difference method is the construction of a discrete grid, the replacement of the continuous derivatives in the governing partial equations with equivalent finite difference expressions. Mentioned transformation is presented in Figure \ref{fig:schematicOfFDM}\cite{bib:fletcher}[p. 64--65].
	
	\begin{figure}
		\centering
		\begin{tikzpicture}%[node distance = 3cm, auto]
			% Place nodes
			\node [block] (setUpGrid) {Set up grid};
			\node [block, right of=setUpGrid, align=center] (initDependentVars) 
			{
				Initialise \\ 
				dependent \\ 
				vairables
			};
			\node [block, right =1cm of initDependentVars, align=center] (construct)
			{
				Construct finite difference \\
				analogue of P.D.E and B.C.s
			};			
			\node [block, below of=construct, align=center] (forEach)
			{
					 For each interior grid point (j, n) \\
					 evaluate algorithm to give $T_j^{n+1}$
			};			
			\node [block, left=1cm of forEach, below of=initDependentVars] (timeStep) 
			{
					$t_{n+1} = t_n + \Delta t$
			};
			\node [block, below of=timeStep, align=center] (adjust) 
			{
					Adjust (if necessary) \\
					boundary values \\
					$T_1^{n+1}$ and $T_j^{n+1}$
			};
			\node [decision, left=1cm of adjust] (final) {Final time reached};
			\node [block, below of=final] (solution) {Solution};
			% Draw edges
			\path [line] (setUpGrid) -- (initDependentVars);
			\path [line] (initDependentVars) -- (construct);
			\path [line] (construct) -- (forEach);
			\path [line] (timeStep) -- (forEach);
			\path [line] (forEach) |- (adjust);
			\path [line] (adjust) -- (final);
			\path [line] (final) |- node {no} (timeStep);
			\path [line] (final) -- node {yes} (solution);
		\end{tikzpicture}
		\caption{Schematic of the finite difference solution process.}
		\label{fig:schematicOfFDM}
	\end{figure}

	General approach mentioned before is a core for algorithm for each of discussed schemes (implicit and explicit upwind, Lax-Wendroff and Richtmyer multi-step). After initialization of the grid and other dependent variables choice is made for finite difference analogue which in our case is particular scheme. Next step in the algorithm is to iterate for given amount of time steps and through all the points that consist for grid. After reaching a final time step or time level actual grid is solution for this time level.
	
	\subsection{Analysis of the schemes} \label{sec:analysis}
		This section is devoted to briefly introduce reader about formulations, stencils and stability conditions, which will be described more precisely in appendix\ref{app:stabilities}. All the formulas are using following dependency \ref{for:cfl}, also known as Courant–Friedrichs–Lewy (CFL) number.
		
		\begin{equation}
			\label{for:cfl}
			C = u \frac{\Delta t}{\Delta x},
		\end{equation} 
		
		where $C$ is the CFL number. In initial parameters of advection function \ref{for:advection} give us $u > 0$ and $\Delta X$ is also greater than $0$ because it refers to amount of points in the grid, which cannot be negative and solution for zero points doesn't make sense. The last important parameter is $\Delta t$ which also should be greater than zero, because it is impossible to go back in time. The conclusion from equation \ref{for:cfl} is that the CFL should always be positive in conditions of considered in this report problem. There is a possibility to change this assumptions but, we will lose the ability to use the following equation $\Delta t = \frac{C\Delta x}{u}$.
		
	\subsection{Explicit upwind scheme} \label{sec:explicitUpwind}
		Formula that gives first-order accurate method for our problem is described in book\cite{bib:hoffman} on pages 191 -- 192 in section 6.5 titled Applications to a Linear Problem, which looks as follows:
		
		\begin{align}
			\label{for:explicitUpwind}
			\begin{split}
				\frac{f_i^{n+1} - f_i^n}{\Delta t} + u\frac{f_i^n - f_{i-1}^n}{\Delta x} = \mathcal{O}(\Delta t, \Delta x) \\
				f_i^{n+1} = f_i^n - C(f_i^n - f_{i-1}^n) + \mathcal{O}(\Delta t^2, \Delta x \Delta t)
			\end{split}
		\end{align}
		
		where $C$ is CFL number introduced earlier \ref{for:cfl}. Geometric arrangement of a nodal group that relate to the points of interest used by this scheme is shown in Figure \ref{fig:explicitUpwind}.
		
		\begin{figure}[!htbp]
			\centering
			\begin{tikzpicture}[scale=1.5]
			\draw[dotted] (-4,0.5) -- (4,0.5);
			\draw[dotted] (-4,-0.5) -- (4,-0.5);
			\node[black] at (-4.5,1) {$n+1$};
			\node[black] at (-4.5,0) {$n$};
			
			\node[black] at (-1,-1) {$i-1$};
			\node[black] at (0,-1) {$i$};
			\node[black] at (1,-1) {$i+1$};
			
			\stencilpt[fill=blue]{0,0}{ij}{};
			\stencilpt[fill=blue]{-1,0}{i-1j}{};			
			\stencilpt{1,0}{i+1j}{};
			
			\stencilpt[fill=green]{0,1}{ij+1}{};
			\stencilpt{-1,1}{i-1j+1}{};			
			\stencilpt{1,1}{i+1j+1}{};
			\draw (ij) -- (i-1j);
			\draw [->](i-1j) -- (ij+1);
			\draw [->](ij) -- (ij+1);
			
			\end{tikzpicture}
			\caption{Graphical representation of the explicit upwind scheme dependencies.}
			\label{fig:explicitUpwind}
		\end{figure}
		
		Described earlier scheme is first-order accurate both in space and time. Stability analysis in appendix \ref{app:explicitUpwind} shows that this method is conditionally stable for: $C \in (0,1)$.
		
		\subsection{Implicit upwind scheme}
			This formulation uses the FTBS method of finite differencing in the approximation of the PDE in \ref{for:advection}, therefore givin:
			
			\begin{equation}
				\label{for:implicitUpwind_first}
				\frac{f_i^{n+1} - f_i^n}{\Delta t} + u\frac{f_i^{n+1} - f_{i-1}^{n+1}}{\Delta x} = \mathcal{O}(\Delta t, \Delta x)
			\end{equation}
	
			The only known value of $f$ at $i$ is at time $n$. Mentioned dependency drives us to solve following linear equation set of form $Af^{n+1} = f^n$:
			
			\begin{equation}
				\begin{bmatrix}
					1+C & & & \\
					-C & 1+C & & \\ 
					& \ddots & \ddots \\
					& & -C & 1+C \\					
				\end{bmatrix} 
				\times
				\begin{bmatrix}
					f_1^{n+1} \\
					f_2^{n+1} \\
					\vdots	\\
					f_N^{n+1}\\
				\end{bmatrix}
				=
				\begin{bmatrix}
					f_1^{n} + C f_0^{n+1}\\
					f_2^{n} \\
					\vdots	\\
					f_N^{n}\\
				\end{bmatrix},
			\end{equation} 
			
			where $N$ is number of grid points.
			
			The opposite of the previous described explicit upwind method this method is second-order accurate both in time and space. We can observe that we do not have to solve it by using complicated algorithm. Matrix $A$ is bidiagonal diagonally-dominant, so although this schema is implicit we can solve it using forward or backward substitution described using formula \ref{for:implicitSubstitution}. This equation assumes that we know the boundary conditions for next time step - $f_o^{n+1}$ and $f_N^{n+1}$.
			
			\begin{align}
				\label{for:implicitSubstitution}
				\begin{split}
					f_i^{n+1} = \frac{f_i^n + Cf_{i-1}^{n+1}}{1+C}\text{, for $i = 1,2,3,\ldots,N-1$ and $C>0$} \\
					f_{i-1}^{n+1} = \frac{(1+C)f_i^{n+1} - f_i^{n+1}}{C}\text{, for $i = N, N-1, \ldots, 2$ and $C < 0$}
				\end{split}
			\end{align}
			
			Graphical interpretation of this method is shown in Figure \ref{fig:implicitUpwind}.
			
			\begin{figure}[!htbp]
				\centering
				\begin{tikzpicture}[scale=1.5]
					\draw[dotted] (-4,0.5) -- (4,0.5);
					\draw[dotted] (-4,-0.5) -- (4,-0.5);
					\draw[dotted] (0.5, 2) -- (0.5, -1.5);
					
					\node[black] at (-1, 1.75) {$C>0$};
					\node[black] at (2, 1.75) {$C<0$};
					\node[black] at (-4.5,1) {$n+1$};
					\node[black] at (-4.5,0) {$n$};
					
					\node[black] at (-2,-1) {$i-1$};
					\node[black] at (-1,-1) {$i$};
					\node[black] at (0,-1) {$i+1$};
					
					\node[black] at (1,-1) {$i-1$};
					\node[black] at (2,-1) {$i$};
					\node[black] at (3,-1) {$i+1$};
					
					\stencilpt[]{-2,0}{i-2j}{};
					\stencilpt[fill=blue]{-1,0}{i-1j}{};
					\stencilpt[]{0,0}{ij}{};
					\stencilpt[]{1,0}{i+1j}{};	
					\stencilpt[fill=blue]{2,0}{i+2j}{};
					\stencilpt[]{3,0}{i+3j}{};
					
					\stencilpt[fill=blue]{-2,1}{i-2j+1}{};
					\stencilpt[fill=green]{-1,1}{i-1j+1}{};
					\stencilpt[]{0,1}{ij+1}{};
					\stencilpt[fill=green]{1,1}{i+1j+1}{};
					\stencilpt[fill=blue]{2,1}{i+2j+1}{};
					\stencilpt[]{3,1}{i+3j+1}{};
					
					\draw (i-2j+1) -- (i-1j);
					\draw [->](i-2j+1) -- (i-1j+1);
					\draw [->](i-1j) -- (i-1j+1);
					
					\draw (i+2j) -- (i+2j+1);
					\draw [->](i+2j+1) -- (i+1j+1);
					\draw [->](i+2j) -- (i+1j+1);
				\end{tikzpicture}
				\caption{Graphical representation of the implicit upwind scheme dependencies.}
				\label{fig:implicitUpwind}
			\end{figure}
			
			The analysis carried out in appendix \ref{app:implicitUpwind} showed that in general schema is stable for $C \in (-\infty, -1) \cup (0, \infty)$, so in terms of assignment ($C>0$) scheme is unconditionally stable. 
			
			% Should I Mention something about negative CFL?